import type { ComponentLayer } from "@/components/ui/ui-builder/types";

export const FUNCTION_REGISTRY_LAYER = {
    "id": "function-registry",
    "type": "div",
    "name": "Function Registry",
    "props": {
      "className": "h-full bg-background px-4 flex flex-col gap-6 min-h-screen",
      "data-group": "data-variables"
    },
    "children": [
      {
        "type": "span",
        "children": "Function Registry",
        "id": "function-registry-title",
        "name": "Text",
        "props": {
          "className": "text-4xl"
        }
      },
      {
        "id": "function-registry-intro",
        "type": "Markdown",
        "name": "Markdown",
        "props": {},
        "children": "**The Function Registry enables binding event handlers to component props from the UI Builder.** This allows users to connect component events like `onClick`, `onSubmit`, and `onChange` to pre-defined functions provided by developers.\n\nThis feature enables:\n- **Interactive components** with real event handlers bound at design time\n- **Form handling** with server actions and validation\n- **User feedback** through toast notifications and alerts\n- **Analytics tracking** and logging through bound functions"
      },
      {
        "id": "function-registry-content",
        "type": "Markdown",
        "name": "Markdown",
        "props": {},
        "children": "## Defining a Function Registry\n\nCreate a function registry with your available functions:\n\n```tsx\nimport { z } from 'zod';\nimport { toast } from 'sonner';\nimport type { FunctionRegistry } from '@/components/ui/ui-builder/types';\n\nconst functionRegistry: FunctionRegistry = {\n  showSuccessToast: {\n    name: \"Show Success Toast\",\n    schema: z.tuple([]),  // No parameters\n    fn: () => {\n      toast.success(\"Action completed!\");\n    },\n    description: \"Shows a success notification\"\n  },\n  handleFormSubmit: {\n    name: \"Submit Form\",\n    schema: z.tuple([z.custom<React.FormEvent>()]),\n    fn: async (e: React.FormEvent<HTMLFormElement>) => {\n      e.preventDefault();\n      const formData = new FormData(e.currentTarget);\n      // Handle form submission\n      await submitToServer(formData);\n      toast.success(\"Form submitted!\");\n    },\n    description: \"Submits form data to server\"\n  },\n  logClick: {\n    name: \"Log Click\",\n    schema: z.tuple([z.custom<React.MouseEvent>()]),\n    fn: (e: React.MouseEvent) => {\n      console.log(\"Button clicked at:\", e.clientX, e.clientY);\n    },\n    description: \"Logs click coordinates to console\"\n  }\n};\n```\n\n## FunctionDefinition Interface\n\nEach function in the registry follows this interface:\n\n```tsx\ninterface FunctionDefinition {\n  /** Human-readable name displayed in the UI */\n  name: string;\n  \n  /** Zod schema describing function parameters */\n  schema: ZodTuple | ZodObject;\n  \n  /** The actual function to call at runtime */\n  fn: (...args: any[]) => any;\n  \n  /** Optional description shown in the UI */\n  description?: string;\n}\n```\n\n## Providing the Function Registry\n\nPass the function registry to the UIBuilder:\n\n```tsx\nimport UIBuilder from '@/components/ui/ui-builder';\n\nfunction App() {\n  return (\n    <UIBuilder\n      componentRegistry={myComponentRegistry}\n      functionRegistry={functionRegistry}\n    />\n  );\n}\n```\n\n## Creating Function Variables\n\nFunction bindings work through the variable system. To bind a function:\n\n1. **Go to the Data panel** in the left sidebar\n2. **Click \"Add Variable\"**\n3. **Select \"Function\" type** (only visible when a function registry is provided)\n4. **Choose a function** from the dropdown\n5. **Save the variable**\n\nThe variable now references a function from your registry.\n\n## Binding Functions to Components\n\nOnce you have a function-type variable, bind it to component event props:\n\n1. **Select a component** with event props (Button, form, etc.)\n2. **Find the event prop** in the props panel (onClick, onSubmit, etc.)\n3. **Click the link icon** to open the binding dropdown\n4. **Select your function variable** from the list\n\nThe function will now be called when the event fires.\n\n## Generated Code\n\nWhen you export code, function bindings generate a clean interface:\n\n```tsx\nimport React from \"react\";\nimport { Button } from \"@/components/ui/button\";\n\ninterface PageProps {\n  variables: {\n    userName: string;\n  };\n  functions: {\n    handleClick: (...args: any[]) => any;\n    handleSubmit: (...args: any[]) => any;\n  };\n}\n\nconst Page = ({ variables, functions }: PageProps) => {\n  return (\n    <div>\n      <span>{variables.userName}</span>\n      <Button onClick={functions.handleClick}>Click Me</Button>\n      <form onSubmit={functions.handleSubmit}>\n        {/* form content */}\n      </form>\n    </div>\n  );\n};\n\nexport default Page;\n```\n\n## Read-Only Rendering with Functions\n\nWhen rendering pages in read-only mode, provide the function registry:\n\n```tsx\nimport LayerRenderer from '@/components/ui/ui-builder/layer-renderer';\n\nfunction ReadOnlyPage() {\n  return (\n    <LayerRenderer\n      page={savedPage}\n      componentRegistry={componentRegistry}\n      variables={[...savedVariables]}\n      functionRegistry={functionRegistry}\n    />\n  );\n}\n```\n\n## Use Cases\n\n### Form Submission with Server Actions\n\n```tsx\nimport { submitFormAction } from './actions';\n\nconst functionRegistry: FunctionRegistry = {\n  handleContactForm: {\n    name: \"Submit Contact Form\",\n    schema: z.tuple([z.custom<React.FormEvent>()]),\n    fn: async (e) => {\n      e.preventDefault();\n      const formData = new FormData(e.currentTarget);\n      const result = await submitFormAction(formData);\n      if (result.success) {\n        toast.success(result.message);\n      } else {\n        toast.error(result.message);\n      }\n    },\n    description: \"Submits contact form to server\"\n  }\n};\n```\n\n### Toast Notifications\n\n```tsx\nconst functionRegistry: FunctionRegistry = {\n  showSuccessToast: {\n    name: \"Show Success\",\n    schema: z.tuple([]),\n    fn: () => toast.success(\"Success!\"),\n    description: \"Shows success toast\"\n  },\n  showErrorToast: {\n    name: \"Show Error\",\n    schema: z.tuple([]),\n    fn: () => toast.error(\"Error!\"),\n    description: \"Shows error toast\"\n  }\n};\n```\n\n### Analytics Tracking\n\n```tsx\nconst functionRegistry: FunctionRegistry = {\n  trackButtonClick: {\n    name: \"Track Button Click\",\n    schema: z.tuple([z.custom<React.MouseEvent>()]),\n    fn: (e) => {\n      analytics.track('button_clicked', {\n        elementId: e.currentTarget.id,\n        timestamp: Date.now()\n      });\n    },\n    description: \"Tracks button click in analytics\"\n  }\n};\n```\n\n## How Function Bindings are Stored\n\nWhen a function is bound to a prop, the layer stores metadata using the `__function_` prefix:\n\n```tsx\n// Layer JSON representation\n{\n  type: \"Button\",\n  props: {\n    __function_onClick: \"handleClick\"  // References function ID\n  }\n}\n```\n\nAt render time, the `resolveVariableReferences` function looks up `handleClick` in the provided function registry and replaces `__function_onClick` with the actual function on the `onClick` prop.\n\n## Fallback Behavior Without Registry\n\n**Important**: If a layer has `__function_*` metadata but no `functionRegistry` is provided to the renderer, the system will:\n\n1. **Log a warning** indicating the missing registry\n2. **Preserve any original prop value** if one exists\n\nThis allows for graceful degradation but should be avoided in production. Always provide a `functionRegistry` when rendering pages that contain function bindings.\n\n```tsx\n// ‚úÖ Correct - provides functionRegistry\n<LayerRenderer\n  page={page}\n  componentRegistry={componentRegistry}\n  functionRegistry={functionRegistry}  // Required for function bindings\n/>\n\n// ‚ö†Ô∏è Warning - missing functionRegistry with function bindings\n<LayerRenderer\n  page={pageWithFunctionBindings}\n  componentRegistry={componentRegistry}\n  // functionRegistry omitted - will log warnings\n/>\n```\n\n## Best Practices\n\n- **Use descriptive names** for functions (e.g., \"Submit Contact Form\" not \"func1\")\n- **Add descriptions** to help users understand what each function does\n- **Handle errors gracefully** with try/catch and user feedback\n- **Keep functions focused** - one function should do one thing\n- **Use async functions** for server actions and API calls\n- **Provide user feedback** via toasts, loading states, etc.\n- **Always provide functionRegistry** when rendering pages with function bindings\n\n## Signature Compatibility\n\nThe function binding system supports flexible signature matching:\n\n- **Extra arguments ignored**: A function that accepts `(a)` can be used where `(a, b, c)` is expected\n- **Object subset matching**: A function accepting `({name})` can be used where `({name, email, phone})` is expected\n\nThis allows reusing simpler functions across multiple contexts.\n\n> üìö **Related**: See [Variables](/docs/variables) for the variable system overview and [Variable Binding](/docs/variable-binding) for general binding mechanics."
      }
    ]
  } as const satisfies ComponentLayer;
